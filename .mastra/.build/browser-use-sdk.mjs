import { createHash } from 'crypto';
import { g as getDefaultExportFromCjs } from './_commonjsHelpers.mjs';
import { z } from './zod.mjs';

/**
 * Serialize a value to JSON
 * @param value A JavaScript value, usually an object or array, to be converted.
 * @param replacer A function that transforms the results.
 * @param space Adds indentation, white space, and line break characters to the return-value JSON text to make it easier to read.
 * @returns JSON string
 */
const toJson = (value, replacer, space) => {
    return JSON.stringify(value, replacer, space);
};
/**
 * Parse JSON string to object, array, or other type
 * @param text A valid JSON string.
 * @param reviver A function that transforms the results. This function is called for each member of the object. If a member contains nested objects, the nested objects are transformed before the parent object is.
 * @returns Parsed object, array, or other type
 */
function fromJson(text, reviver) {
    return JSON.parse(text, reviver);
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
class BrowserUseError extends Error {
    constructor({ message, statusCode, body, rawResponse, }) {
        super(buildMessage({ message, statusCode, body }));
        Object.setPrototypeOf(this, BrowserUseError.prototype);
        this.statusCode = statusCode;
        this.body = body;
        this.rawResponse = rawResponse;
    }
}
function buildMessage({ message, statusCode, body, }) {
    let lines = [];
    if (message != null) {
        lines.push(message);
    }
    if (statusCode != null) {
        lines.push(`Status code: ${statusCode.toString()}`);
    }
    if (body != null) {
        lines.push(`Body: ${toJson(body, undefined, 2)}`);
    }
    return lines.join("\n");
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
class BrowserUseTimeoutError extends Error {
    constructor(message) {
        super(message);
        Object.setPrototypeOf(this, BrowserUseTimeoutError.prototype);
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
class NotFoundError extends BrowserUseError {
    constructor(body, rawResponse) {
        super({
            message: "NotFoundError",
            statusCode: 404,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, NotFoundError.prototype);
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
class UnprocessableEntityError extends BrowserUseError {
    constructor(body, rawResponse) {
        super({
            message: "UnprocessableEntityError",
            statusCode: 422,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, UnprocessableEntityError.prototype);
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
class BadRequestError extends BrowserUseError {
    constructor(body, rawResponse) {
        super({
            message: "BadRequestError",
            statusCode: 400,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, BadRequestError.prototype);
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
class TooManyRequestsError extends BrowserUseError {
    constructor(body, rawResponse) {
        super({
            message: "TooManyRequestsError",
            statusCode: 429,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, TooManyRequestsError.prototype);
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
class InternalServerError extends BrowserUseError {
    constructor(body, rawResponse) {
        super({
            message: "InternalServerError",
            statusCode: 500,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, InternalServerError.prototype);
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
class PaymentRequiredError extends BrowserUseError {
    constructor(body, rawResponse) {
        super({
            message: "PaymentRequiredError",
            statusCode: 402,
            body: body,
            rawResponse: rawResponse,
        });
        Object.setPrototypeOf(this, PaymentRequiredError.prototype);
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
const BrowserUseEnvironment = {
    Production: "https://api.browser-use.com/api/v2",
};

const defaultQsOptions = {
    arrayFormat: "indices",
    encode: true,
};
function encodeValue(value, shouldEncode) {
    if (value === undefined) {
        return "";
    }
    if (value === null) {
        return "";
    }
    const stringValue = String(value);
    return shouldEncode ? encodeURIComponent(stringValue) : stringValue;
}
function stringifyObject(obj, prefix = "", options) {
    const parts = [];
    for (const [key, value] of Object.entries(obj)) {
        const fullKey = prefix ? `${prefix}[${key}]` : key;
        if (value === undefined) {
            continue;
        }
        if (Array.isArray(value)) {
            if (value.length === 0) {
                continue;
            }
            for (let i = 0; i < value.length; i++) {
                const item = value[i];
                if (item === undefined) {
                    continue;
                }
                if (typeof item === "object" && !Array.isArray(item) && item !== null) {
                    const arrayKey = options.arrayFormat === "indices" ? `${fullKey}[${i}]` : fullKey;
                    parts.push(...stringifyObject(item, arrayKey, options));
                }
                else {
                    const arrayKey = options.arrayFormat === "indices" ? `${fullKey}[${i}]` : fullKey;
                    const encodedKey = options.encode ? encodeURIComponent(arrayKey) : arrayKey;
                    parts.push(`${encodedKey}=${encodeValue(item, options.encode)}`);
                }
            }
        }
        else if (typeof value === "object" && value !== null) {
            if (Object.keys(value).length === 0) {
                continue;
            }
            parts.push(...stringifyObject(value, fullKey, options));
        }
        else {
            const encodedKey = options.encode ? encodeURIComponent(fullKey) : fullKey;
            parts.push(`${encodedKey}=${encodeValue(value, options.encode)}`);
        }
    }
    return parts;
}
function toQueryString(obj, options) {
    if (obj == null || typeof obj !== "object") {
        return "";
    }
    const parts = stringifyObject(obj, "", Object.assign(Object.assign({}, defaultQsOptions), options));
    return parts.join("&");
}

function createRequestUrl(baseUrl, queryParameters) {
    const queryString = toQueryString(queryParameters, { arrayFormat: "repeat" });
    return queryString ? `${baseUrl}?${queryString}` : baseUrl;
}

function getBinaryResponse(response) {
    const binaryResponse = {
        get bodyUsed() {
            return response.bodyUsed;
        },
        stream: () => response.body,
        arrayBuffer: response.arrayBuffer.bind(response),
        blob: response.blob.bind(response),
    };
    if ("bytes" in response && typeof response.bytes === "function") {
        binaryResponse.bytes = response.bytes.bind(response);
    }
    return binaryResponse;
}

function isResponseWithBody(response) {
    return response.body != null;
}

var __awaiter$e = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getResponseBody(response, responseType) {
    return __awaiter$e(this, void 0, void 0, function* () {
        if (!isResponseWithBody(response)) {
            return undefined;
        }
        switch (responseType) {
            case "binary-response":
                return getBinaryResponse(response);
            case "blob":
                return yield response.blob();
            case "arrayBuffer":
                return yield response.arrayBuffer();
            case "sse":
                return response.body;
            case "streaming":
                return response.body;
            case "text":
                return yield response.text();
        }
        // if responseType is "json" or not specified, try to parse as JSON
        const text = yield response.text();
        if (text.length > 0) {
            try {
                let responseBody = fromJson(text);
                return responseBody;
            }
            catch (err) {
                return {
                    ok: false,
                    error: {
                        reason: "non-json",
                        statusCode: response.status,
                        rawBody: text,
                    },
                };
            }
        }
        return undefined;
    });
}

var __awaiter$d = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getErrorResponseBody(response) {
    return __awaiter$d(this, void 0, void 0, function* () {
        var _a, _b, _c;
        let contentType = (_a = response.headers.get("Content-Type")) === null || _a === void 0 ? void 0 : _a.toLowerCase();
        if (contentType == null || contentType.length === 0) {
            return getResponseBody(response);
        }
        if (contentType.indexOf(";") !== -1) {
            contentType = (_c = (_b = contentType.split(";")[0]) === null || _b === void 0 ? void 0 : _b.trim()) !== null && _c !== void 0 ? _c : "";
        }
        switch (contentType) {
            case "application/hal+json":
            case "application/json":
            case "application/ld+json":
            case "application/problem+json":
            case "application/vnd.api+json":
            case "text/json":
                const text = yield response.text();
                return text.length > 0 ? fromJson(text) : undefined;
            default:
                if (contentType.startsWith("application/vnd.") && contentType.endsWith("+json")) {
                    const text = yield response.text();
                    return text.length > 0 ? fromJson(text) : undefined;
                }
                // Fallback to plain text if content type is not recognized
                // Even if no body is present, the response will be an empty string
                return yield response.text();
        }
    });
}

var __awaiter$c = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getFetchFn() {
    return __awaiter$c(this, void 0, void 0, function* () {
        return fetch;
    });
}

var __awaiter$b = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getRequestBody(_a) {
    return __awaiter$b(this, arguments, void 0, function* ({ body, type }) {
        if (type.includes("json")) {
            return toJson(body);
        }
        else {
            return body;
        }
    });
}

const TIMEOUT = "timeout";
function getTimeoutSignal(timeoutMs) {
    const controller = new AbortController();
    const abortId = setTimeout(() => controller.abort(TIMEOUT), timeoutMs);
    return { signal: controller.signal, abortId };
}
/**
 * Returns an abort signal that is getting aborted when
 * at least one of the specified abort signals is aborted.
 *
 * Requires at least node.js 18.
 */
function anySignal(...args) {
    // Allowing signals to be passed either as array
    // of signals or as multiple arguments.
    const signals = (args.length === 1 && Array.isArray(args[0]) ? args[0] : args);
    const controller = new AbortController();
    for (const signal of signals) {
        if (signal.aborted) {
            // Exiting early if one of the signals
            // is already aborted.
            controller.abort(signal === null || signal === void 0 ? void 0 : signal.reason);
            break;
        }
        // Listening for signals and removing the listeners
        // when at least one symbol is aborted.
        signal.addEventListener("abort", () => controller.abort(signal === null || signal === void 0 ? void 0 : signal.reason), {
            signal: controller.signal,
        });
    }
    return controller.signal;
}

var __awaiter$a = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const makeRequest = (fetchFn, url, method, headers, requestBody, timeoutMs, abortSignal, withCredentials, duplex) => __awaiter$a(void 0, void 0, void 0, function* () {
    const signals = [];
    // Add timeout signal
    let timeoutAbortId = undefined;
    if (timeoutMs != null) {
        const { signal, abortId } = getTimeoutSignal(timeoutMs);
        timeoutAbortId = abortId;
        signals.push(signal);
    }
    // Add arbitrary signal
    if (abortSignal != null) {
        signals.push(abortSignal);
    }
    let newSignals = anySignal(signals);
    const response = yield fetchFn(url, {
        method: method,
        headers,
        body: requestBody,
        signal: newSignals,
        credentials: withCredentials ? "include" : undefined,
        // @ts-ignore
        duplex,
    });
    if (timeoutAbortId != null) {
        clearTimeout(timeoutAbortId);
    }
    return response;
});

let Headers;
if (typeof globalThis.Headers !== "undefined") {
    Headers = globalThis.Headers;
}
else {
    Headers = class Headers {
        constructor(init) {
            this.headers = new Map();
            if (init) {
                if (init instanceof Headers) {
                    init.forEach((value, key) => this.append(key, value));
                }
                else if (Array.isArray(init)) {
                    for (const [key, value] of init) {
                        if (typeof key === "string" && typeof value === "string") {
                            this.append(key, value);
                        }
                        else {
                            throw new TypeError("Each header entry must be a [string, string] tuple");
                        }
                    }
                }
                else {
                    for (const [key, value] of Object.entries(init)) {
                        if (typeof value === "string") {
                            this.append(key, value);
                        }
                        else {
                            throw new TypeError("Header values must be strings");
                        }
                    }
                }
            }
        }
        append(name, value) {
            const key = name.toLowerCase();
            const existing = this.headers.get(key) || [];
            this.headers.set(key, [...existing, value]);
        }
        delete(name) {
            const key = name.toLowerCase();
            this.headers.delete(key);
        }
        get(name) {
            const key = name.toLowerCase();
            const values = this.headers.get(key);
            return values ? values.join(", ") : null;
        }
        has(name) {
            const key = name.toLowerCase();
            return this.headers.has(key);
        }
        set(name, value) {
            const key = name.toLowerCase();
            this.headers.set(key, [value]);
        }
        forEach(callbackfn, thisArg) {
            const boundCallback = thisArg ? callbackfn.bind(thisArg) : callbackfn;
            this.headers.forEach((values, key) => boundCallback(values.join(", "), key, this));
        }
        getSetCookie() {
            return this.headers.get("set-cookie") || [];
        }
        *entries() {
            for (const [key, values] of this.headers.entries()) {
                yield [key, values.join(", ")];
            }
        }
        *keys() {
            yield* this.headers.keys();
        }
        *values() {
            for (const values of this.headers.values()) {
                yield values.join(", ");
            }
        }
        [Symbol.iterator]() {
            return this.entries();
        }
    };
}

/**
 * A raw response indicating that the request was aborted.
 */
const abortRawResponse = {
    headers: new Headers(),
    redirected: false,
    status: 499,
    statusText: "Client Closed Request",
    type: "error",
    url: "",
};
/**
 * A raw response indicating an unknown error.
 */
const unknownRawResponse = {
    headers: new Headers(),
    redirected: false,
    status: 0,
    statusText: "Unknown Error",
    type: "error",
    url: "",
};
/**
 * Converts a `RawResponse` object into a `RawResponse` by extracting its properties,
 * excluding the `body` and `bodyUsed` fields.
 *
 * @param response - The `RawResponse` object to convert.
 * @returns A `RawResponse` object containing the extracted properties of the input response.
 */
function toRawResponse(response) {
    return {
        headers: response.headers,
        redirected: response.redirected,
        status: response.status,
        statusText: response.statusText,
        type: response.type,
        url: response.url,
    };
}

var __awaiter$9 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const INITIAL_RETRY_DELAY = 1000; // in milliseconds
const MAX_RETRY_DELAY = 60000; // in milliseconds
const DEFAULT_MAX_RETRIES = 2;
const JITTER_FACTOR = 0.2; // 20% random jitter
function addJitter(delay) {
    // Generate a random value between -JITTER_FACTOR and +JITTER_FACTOR
    const jitterMultiplier = 1 + (Math.random() * 2 - 1) * JITTER_FACTOR;
    return delay * jitterMultiplier;
}
function requestWithRetries(requestFn_1) {
    return __awaiter$9(this, arguments, void 0, function* (requestFn, maxRetries = DEFAULT_MAX_RETRIES) {
        let response = yield requestFn();
        for (let i = 0; i < maxRetries; ++i) {
            if ([408, 429].includes(response.status) || response.status >= 500) {
                // Calculate base delay using exponential backoff (in milliseconds)
                const baseDelay = Math.min(INITIAL_RETRY_DELAY * Math.pow(2, i), MAX_RETRY_DELAY);
                // Add jitter to the delay
                const delayWithJitter = addJitter(baseDelay);
                yield new Promise((resolve) => setTimeout(resolve, delayWithJitter));
                response = yield requestFn();
            }
            else {
                break;
            }
        }
        return response;
    });
}

var __awaiter$8 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const Supplier = {
    get: (supplier) => __awaiter$8(void 0, void 0, void 0, function* () {
        if (typeof supplier === "function") {
            return supplier();
        }
        else {
            return supplier;
        }
    }),
};

var __awaiter$7 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function getHeaders(args) {
    return __awaiter$7(this, void 0, void 0, function* () {
        const newHeaders = {};
        if (args.body !== undefined && args.contentType != null) {
            newHeaders["Content-Type"] = args.contentType;
        }
        if (args.headers == null) {
            return newHeaders;
        }
        for (const [key, value] of Object.entries(args.headers)) {
            const result = yield Supplier.get(value);
            if (typeof result === "string") {
                newHeaders[key] = result;
                continue;
            }
            if (result == null) {
                continue;
            }
            newHeaders[key] = `${result}`;
        }
        return newHeaders;
    });
}
function fetcherImpl(args) {
    return __awaiter$7(this, void 0, void 0, function* () {
        const url = createRequestUrl(args.url, args.queryParameters);
        const requestBody = yield getRequestBody({
            body: args.body,
            type: args.requestType === "json" ? "json" : "other",
        });
        const fetchFn = yield getFetchFn();
        try {
            const response = yield requestWithRetries(() => __awaiter$7(this, void 0, void 0, function* () {
                return makeRequest(fetchFn, url, args.method, yield getHeaders(args), requestBody, args.timeoutMs, args.abortSignal, args.withCredentials, args.duplex);
            }), args.maxRetries);
            if (response.status >= 200 && response.status < 400) {
                return {
                    ok: true,
                    body: (yield getResponseBody(response, args.responseType)),
                    headers: response.headers,
                    rawResponse: toRawResponse(response),
                };
            }
            else {
                return {
                    ok: false,
                    error: {
                        reason: "status-code",
                        statusCode: response.status,
                        body: yield getErrorResponseBody(response),
                    },
                    rawResponse: toRawResponse(response),
                };
            }
        }
        catch (error) {
            if (args.abortSignal != null && args.abortSignal.aborted) {
                return {
                    ok: false,
                    error: {
                        reason: "unknown",
                        errorMessage: "The user aborted a request",
                    },
                    rawResponse: abortRawResponse,
                };
            }
            else if (error instanceof Error && error.name === "AbortError") {
                return {
                    ok: false,
                    error: {
                        reason: "timeout",
                    },
                    rawResponse: abortRawResponse,
                };
            }
            else if (error instanceof Error) {
                return {
                    ok: false,
                    error: {
                        reason: "unknown",
                        errorMessage: error.message,
                    },
                    rawResponse: unknownRawResponse,
                };
            }
            return {
                ok: false,
                error: {
                    reason: "unknown",
                    errorMessage: toJson(error),
                },
                rawResponse: unknownRawResponse,
            };
        }
    });
}
const fetcher = fetcherImpl;

var __awaiter$6 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
/**
 * A promise that returns the parsed response and lets you retrieve the raw response too.
 */
class HttpResponsePromise extends Promise {
    constructor(promise) {
        // Initialize with a no-op to avoid premature parsing
        super((resolve) => {
            resolve(undefined);
        });
        this.innerPromise = promise;
    }
    /**
     * Creates an `HttpResponsePromise` from a function that returns a promise.
     *
     * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
     * @param args - Arguments to pass to the function.
     * @returns An `HttpResponsePromise` instance.
     */
    static fromFunction(fn, ...args) {
        return new HttpResponsePromise(fn(...args));
    }
    /**
     * Creates a function that returns an `HttpResponsePromise` from a function that returns a promise.
     *
     * @param fn - A function that returns a promise resolving to a `WithRawResponse` object.
     * @returns A function that returns an `HttpResponsePromise` instance.
     */
    static interceptFunction(fn) {
        return (...args) => {
            return HttpResponsePromise.fromPromise(fn(...args));
        };
    }
    /**
     * Creates an `HttpResponsePromise` from an existing promise.
     *
     * @param promise - A promise resolving to a `WithRawResponse` object.
     * @returns An `HttpResponsePromise` instance.
     */
    static fromPromise(promise) {
        return new HttpResponsePromise(promise);
    }
    /**
     * Creates an `HttpResponsePromise` from an executor function.
     *
     * @param executor - A function that takes resolve and reject callbacks to create a promise.
     * @returns An `HttpResponsePromise` instance.
     */
    static fromExecutor(executor) {
        const promise = new Promise(executor);
        return new HttpResponsePromise(promise);
    }
    /**
     * Creates an `HttpResponsePromise` from a resolved result.
     *
     * @param result - A `WithRawResponse` object to resolve immediately.
     * @returns An `HttpResponsePromise` instance.
     */
    static fromResult(result) {
        const promise = Promise.resolve(result);
        return new HttpResponsePromise(promise);
    }
    unwrap() {
        if (!this.unwrappedPromise) {
            this.unwrappedPromise = this.innerPromise.then(({ data }) => data);
        }
        return this.unwrappedPromise;
    }
    /** @inheritdoc */
    then(onfulfilled, onrejected) {
        return this.unwrap().then(onfulfilled, onrejected);
    }
    /** @inheritdoc */
    catch(onrejected) {
        return this.unwrap().catch(onrejected);
    }
    /** @inheritdoc */
    finally(onfinally) {
        return this.unwrap().finally(onfinally);
    }
    /**
     * Retrieves the data and raw response.
     *
     * @returns A promise resolving to a `WithRawResponse` object.
     */
    withRawResponse() {
        return __awaiter$6(this, void 0, void 0, function* () {
            return yield this.innerPromise;
        });
    }
}

/**
 * A constant that indicates which environment and version the SDK is running in.
 */
const RUNTIME = evaluateRuntime();
function evaluateRuntime() {
    var _a, _b, _c, _d, _e;
    /**
     * A constant that indicates whether the environment the code is running is a Web Browser.
     */
    const isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
    if (isBrowser) {
        return {
            type: "browser",
            version: window.navigator.userAgent,
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is Cloudflare.
     * https://developers.cloudflare.com/workers/runtime-apis/web-standards/#navigatoruseragent
     */
    const isCloudflare = typeof globalThis !== "undefined" && ((_a = globalThis === null || globalThis === void 0 ? void 0 : globalThis.navigator) === null || _a === void 0 ? void 0 : _a.userAgent) === "Cloudflare-Workers";
    if (isCloudflare) {
        return {
            type: "workerd",
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is Edge Runtime.
     * https://vercel.com/docs/functions/runtimes/edge-runtime#check-if-you're-running-on-the-edge-runtime
     */
    const isEdgeRuntime = typeof EdgeRuntime === "string";
    if (isEdgeRuntime) {
        return {
            type: "edge-runtime",
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is a Web Worker.
     */
    const isWebWorker = typeof self === "object" &&
        typeof (self === null || self === void 0 ? void 0 : self.importScripts) === "function" &&
        (((_b = self.constructor) === null || _b === void 0 ? void 0 : _b.name) === "DedicatedWorkerGlobalScope" ||
            ((_c = self.constructor) === null || _c === void 0 ? void 0 : _c.name) === "ServiceWorkerGlobalScope" ||
            ((_d = self.constructor) === null || _d === void 0 ? void 0 : _d.name) === "SharedWorkerGlobalScope");
    if (isWebWorker) {
        return {
            type: "web-worker",
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is Deno.
     * FYI Deno spoofs process.versions.node, see https://deno.land/std@0.177.0/node/process.ts?s=versions
     */
    const isDeno = typeof Deno !== "undefined" && typeof Deno.version !== "undefined" && typeof Deno.version.deno !== "undefined";
    if (isDeno) {
        return {
            type: "deno",
            version: Deno.version.deno,
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is Bun.sh.
     */
    const isBun = typeof Bun !== "undefined" && typeof Bun.version !== "undefined";
    if (isBun) {
        return {
            type: "bun",
            version: Bun.version,
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is Node.JS.
     */
    const isNode = typeof process !== "undefined" &&
        "version" in process &&
        !!process.version &&
        "versions" in process &&
        !!((_e = process.versions) === null || _e === void 0 ? void 0 : _e.node);
    if (isNode) {
        return {
            type: "node",
            version: process.versions.node,
            parsedVersion: Number(process.versions.node.split(".")[0]),
        };
    }
    /**
     * A constant that indicates whether the environment the code is running is in React-Native.
     * https://github.com/facebook/react-native/blob/main/packages/react-native/Libraries/Core/setUpNavigator.js
     */
    const isReactNative = typeof navigator !== "undefined" && (navigator === null || navigator === void 0 ? void 0 : navigator.product) === "ReactNative";
    if (isReactNative) {
        return {
            type: "react-native",
        };
    }
    return {
        type: "unknown",
    };
}

function join(base, ...segments) {
    if (!base) {
        return "";
    }
    if (segments.length === 0) {
        return base;
    }
    if (base.includes("://")) {
        let url;
        try {
            url = new URL(base);
        }
        catch (_a) {
            // Fallback to path joining if URL is malformed
            return joinPath(base, ...segments);
        }
        const lastSegment = segments[segments.length - 1];
        const shouldPreserveTrailingSlash = lastSegment && lastSegment.endsWith("/");
        for (const segment of segments) {
            const cleanSegment = trimSlashes(segment);
            if (cleanSegment) {
                url.pathname = joinPathSegments(url.pathname, cleanSegment);
            }
        }
        if (shouldPreserveTrailingSlash && !url.pathname.endsWith("/")) {
            url.pathname += "/";
        }
        return url.toString();
    }
    return joinPath(base, ...segments);
}
function joinPath(base, ...segments) {
    if (segments.length === 0) {
        return base;
    }
    let result = base;
    const lastSegment = segments[segments.length - 1];
    const shouldPreserveTrailingSlash = lastSegment && lastSegment.endsWith("/");
    for (const segment of segments) {
        const cleanSegment = trimSlashes(segment);
        if (cleanSegment) {
            result = joinPathSegments(result, cleanSegment);
        }
    }
    if (shouldPreserveTrailingSlash && !result.endsWith("/")) {
        result += "/";
    }
    return result;
}
function joinPathSegments(left, right) {
    if (left.endsWith("/")) {
        return left + right;
    }
    return left + "/" + right;
}
function trimSlashes(str) {
    if (!str)
        return str;
    let start = 0;
    let end = str.length;
    if (str.startsWith("/"))
        start = 1;
    if (str.endsWith("/"))
        end = str.length - 1;
    return start === 0 && end === str.length ? str : str.slice(start, end);
}

function mergeHeaders(...headersArray) {
    const result = {};
    for (const [key, value] of headersArray
        .filter((headers) => headers != null)
        .flatMap((headers) => Object.entries(headers))) {
        if (value != null) {
            result[key] = value;
        }
        else if (key in result) {
            delete result[key];
        }
    }
    return result;
}
function mergeOnlyDefinedHeaders(...headersArray) {
    const result = {};
    for (const [key, value] of headersArray
        .filter((headers) => headers != null)
        .flatMap((headers) => Object.entries(headers))) {
        if (value != null) {
            result[key] = value;
        }
    }
    return result;
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __awaiter$5 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Accounts {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * Get authenticated account information including credit balances and account details.
     *
     * @param {Accounts.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.NotFoundError}
     *
     * @example
     *     await client.accounts.getAccountMe()
     */
    getAccountMe(requestOptions) {
        return HttpResponsePromise.fromPromise(this.__getAccountMe(requestOptions));
    }
    __getAccountMe(requestOptions) {
        return __awaiter$5(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, "accounts/me"),
                method: "GET",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 404:
                        throw new NotFoundError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling GET /accounts/me.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    _getCustomAuthorizationHeaders() {
        return __awaiter$5(this, void 0, void 0, function* () {
            const apiKeyValue = yield Supplier.get(this._options.apiKey);
            return { "X-Browser-Use-API-Key": apiKeyValue };
        });
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __awaiter$4 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Tasks {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * Get paginated list of AI agent tasks with optional filtering by session and status.
     *
     * @param {BrowserUse.ListTasksTasksGetRequest} request
     * @param {Tasks.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.UnprocessableEntityError}
     *
     * @example
     *     await client.tasks.listTasks()
     */
    listTasks(request = {}, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__listTasks(request, requestOptions));
    }
    __listTasks() {
        return __awaiter$4(this, arguments, void 0, function* (request = {}, requestOptions) {
            var _a, _b, _c;
            const { pageSize, pageNumber, sessionId, filterBy, after, before } = request;
            const _queryParams = {};
            if (pageSize != null) {
                _queryParams["pageSize"] = pageSize.toString();
            }
            if (pageNumber != null) {
                _queryParams["pageNumber"] = pageNumber.toString();
            }
            if (sessionId != null) {
                _queryParams["sessionId"] = sessionId;
            }
            if (filterBy != null) {
                _queryParams["filterBy"] = filterBy;
            }
            if (after != null) {
                _queryParams["after"] = after;
            }
            if (before != null) {
                _queryParams["before"] = before;
            }
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, "tasks"),
                method: "GET",
                headers: _headers,
                queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling GET /tasks.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * You can either:
     * 1. Start a new task (auto creates a new simple session)
     * 2. Start a new task in an existing session (you can create a custom session before starting the task and reuse it for follow-up tasks)
     *
     * @param {BrowserUse.CreateTaskRequest} request
     * @param {Tasks.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.BadRequestError}
     * @throws {@link BrowserUse.NotFoundError}
     * @throws {@link BrowserUse.UnprocessableEntityError}
     * @throws {@link BrowserUse.TooManyRequestsError}
     *
     * @example
     *     await client.tasks.createTask({
     *         task: "task"
     *     })
     */
    createTask(request, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__createTask(request, requestOptions));
    }
    __createTask(request, requestOptions) {
        return __awaiter$4(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, "tasks"),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: request,
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new BadRequestError(_response.error.body, _response.rawResponse);
                    case 404:
                        throw new NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    case 429:
                        throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling POST /tasks.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Get detailed task information including status, progress, steps, and file outputs.
     *
     * @param {string} taskId
     * @param {Tasks.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.NotFoundError}
     * @throws {@link BrowserUse.UnprocessableEntityError}
     *
     * @example
     *     await client.tasks.getTask("task_id")
     */
    getTask(taskId, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__getTask(taskId, requestOptions));
    }
    __getTask(taskId, requestOptions) {
        return __awaiter$4(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, `tasks/${encodeURIComponent(taskId)}`),
                method: "GET",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 404:
                        throw new NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling GET /tasks/{task_id}.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Control task execution with stop, pause, resume, or stop task and session actions.
     *
     * @param {string} taskId
     * @param {BrowserUse.UpdateTaskRequest} request
     * @param {Tasks.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.NotFoundError}
     * @throws {@link BrowserUse.UnprocessableEntityError}
     *
     * @example
     *     await client.tasks.updateTask("task_id", {
     *         action: "stop"
     *     })
     */
    updateTask(taskId, request, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__updateTask(taskId, request, requestOptions));
    }
    __updateTask(taskId, request, requestOptions) {
        return __awaiter$4(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, `tasks/${encodeURIComponent(taskId)}`),
                method: "PATCH",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: request,
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 404:
                        throw new NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling PATCH /tasks/{task_id}.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Get secure download URL for task execution logs with step-by-step details.
     *
     * @param {string} taskId
     * @param {Tasks.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.NotFoundError}
     * @throws {@link BrowserUse.UnprocessableEntityError}
     * @throws {@link BrowserUse.InternalServerError}
     *
     * @example
     *     await client.tasks.getTaskLogs("task_id")
     */
    getTaskLogs(taskId, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__getTaskLogs(taskId, requestOptions));
    }
    __getTaskLogs(taskId, requestOptions) {
        return __awaiter$4(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, `tasks/${encodeURIComponent(taskId)}/logs`),
                method: "GET",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 404:
                        throw new NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    case 500:
                        throw new InternalServerError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling GET /tasks/{task_id}/logs.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    _getCustomAuthorizationHeaders() {
        return __awaiter$4(this, void 0, void 0, function* () {
            const apiKeyValue = yield Supplier.get(this._options.apiKey);
            return { "X-Browser-Use-API-Key": apiKeyValue };
        });
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __awaiter$3 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Sessions {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * Get paginated list of AI agent sessions with optional status filtering.
     *
     * @param {BrowserUse.ListSessionsSessionsGetRequest} request
     * @param {Sessions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.UnprocessableEntityError}
     *
     * @example
     *     await client.sessions.listSessions()
     */
    listSessions(request = {}, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__listSessions(request, requestOptions));
    }
    __listSessions() {
        return __awaiter$3(this, arguments, void 0, function* (request = {}, requestOptions) {
            var _a, _b, _c;
            const { pageSize, pageNumber, filterBy } = request;
            const _queryParams = {};
            if (pageSize != null) {
                _queryParams["pageSize"] = pageSize.toString();
            }
            if (pageNumber != null) {
                _queryParams["pageNumber"] = pageNumber.toString();
            }
            if (filterBy != null) {
                _queryParams["filterBy"] = filterBy;
            }
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, "sessions"),
                method: "GET",
                headers: _headers,
                queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling GET /sessions.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Create a new session with a new task.
     *
     * @param {BrowserUse.CreateSessionRequest} request
     * @param {Sessions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.NotFoundError}
     * @throws {@link BrowserUse.UnprocessableEntityError}
     * @throws {@link BrowserUse.TooManyRequestsError}
     *
     * @example
     *     await client.sessions.createSession()
     */
    createSession(request = {}, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__createSession(request, requestOptions));
    }
    __createSession() {
        return __awaiter$3(this, arguments, void 0, function* (request = {}, requestOptions) {
            var _a, _b, _c;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, "sessions"),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: request,
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 404:
                        throw new NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    case 429:
                        throw new TooManyRequestsError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling POST /sessions.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Get detailed session information including status, URLs, and task details.
     *
     * @param {string} sessionId
     * @param {Sessions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.NotFoundError}
     * @throws {@link BrowserUse.UnprocessableEntityError}
     *
     * @example
     *     await client.sessions.getSession("session_id")
     */
    getSession(sessionId, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__getSession(sessionId, requestOptions));
    }
    __getSession(sessionId, requestOptions) {
        return __awaiter$3(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, `sessions/${encodeURIComponent(sessionId)}`),
                method: "GET",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 404:
                        throw new NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling GET /sessions/{session_id}.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Stop a session and all its running tasks.
     *
     * @param {string} sessionId
     * @param {BrowserUse.UpdateSessionRequest} request
     * @param {Sessions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.NotFoundError}
     * @throws {@link BrowserUse.UnprocessableEntityError}
     *
     * @example
     *     await client.sessions.updateSession("session_id", {})
     */
    updateSession(sessionId, request, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__updateSession(sessionId, request, requestOptions));
    }
    __updateSession(sessionId, request, requestOptions) {
        return __awaiter$3(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, `sessions/${encodeURIComponent(sessionId)}`),
                method: "PATCH",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: Object.assign(Object.assign({}, request), { action: "stop" }),
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 404:
                        throw new NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling PATCH /sessions/{session_id}.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Get public share information including URL and usage statistics.
     *
     * @param {string} sessionId
     * @param {Sessions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.NotFoundError}
     * @throws {@link BrowserUse.UnprocessableEntityError}
     *
     * @example
     *     await client.sessions.getSessionPublicShare("session_id")
     */
    getSessionPublicShare(sessionId, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__getSessionPublicShare(sessionId, requestOptions));
    }
    __getSessionPublicShare(sessionId, requestOptions) {
        return __awaiter$3(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, `sessions/${encodeURIComponent(sessionId)}/public-share`),
                method: "GET",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 404:
                        throw new NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling GET /sessions/{session_id}/public-share.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Create or return existing public share for a session.
     *
     * @param {string} sessionId
     * @param {Sessions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.NotFoundError}
     * @throws {@link BrowserUse.UnprocessableEntityError}
     *
     * @example
     *     await client.sessions.createSessionPublicShare("session_id")
     */
    createSessionPublicShare(sessionId, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__createSessionPublicShare(sessionId, requestOptions));
    }
    __createSessionPublicShare(sessionId, requestOptions) {
        return __awaiter$3(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, `sessions/${encodeURIComponent(sessionId)}/public-share`),
                method: "POST",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 404:
                        throw new NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling POST /sessions/{session_id}/public-share.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Remove public share for a session.
     *
     * @param {string} sessionId
     * @param {Sessions.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.NotFoundError}
     * @throws {@link BrowserUse.UnprocessableEntityError}
     *
     * @example
     *     await client.sessions.deleteSessionPublicShare("session_id")
     */
    deleteSessionPublicShare(sessionId, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__deleteSessionPublicShare(sessionId, requestOptions));
    }
    __deleteSessionPublicShare(sessionId, requestOptions) {
        return __awaiter$3(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, `sessions/${encodeURIComponent(sessionId)}/public-share`),
                method: "DELETE",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: undefined, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 404:
                        throw new NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling DELETE /sessions/{session_id}/public-share.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    _getCustomAuthorizationHeaders() {
        return __awaiter$3(this, void 0, void 0, function* () {
            const apiKeyValue = yield Supplier.get(this._options.apiKey);
            return { "X-Browser-Use-API-Key": apiKeyValue };
        });
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __awaiter$2 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Files {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * Generate a secure presigned URL for uploading files that AI agents can use during tasks.
     *
     * @param {string} sessionId
     * @param {BrowserUse.UploadFileRequest} request
     * @param {Files.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.BadRequestError}
     * @throws {@link BrowserUse.NotFoundError}
     * @throws {@link BrowserUse.UnprocessableEntityError}
     * @throws {@link BrowserUse.InternalServerError}
     *
     * @example
     *     await client.files.userUploadFilePresignedUrl("session_id", {
     *         fileName: "fileName",
     *         contentType: "image/jpg",
     *         sizeBytes: 1
     *     })
     */
    userUploadFilePresignedUrl(sessionId, request, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__userUploadFilePresignedUrl(sessionId, request, requestOptions));
    }
    __userUploadFilePresignedUrl(sessionId, request, requestOptions) {
        return __awaiter$2(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, `files/sessions/${encodeURIComponent(sessionId)}/presigned-url`),
                method: "POST",
                headers: _headers,
                contentType: "application/json",
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                requestType: "json",
                body: request,
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return {
                    data: _response.body,
                    rawResponse: _response.rawResponse,
                };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 400:
                        throw new BadRequestError(_response.error.body, _response.rawResponse);
                    case 404:
                        throw new NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    case 500:
                        throw new InternalServerError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling POST /files/sessions/{session_id}/presigned-url.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Get secure download URL for an output file generated by the AI agent.
     *
     * @param {string} taskId
     * @param {string} fileId
     * @param {Files.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.NotFoundError}
     * @throws {@link BrowserUse.UnprocessableEntityError}
     * @throws {@link BrowserUse.InternalServerError}
     *
     * @example
     *     await client.files.getTaskOutputFilePresignedUrl("task_id", "file_id")
     */
    getTaskOutputFilePresignedUrl(taskId, fileId, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__getTaskOutputFilePresignedUrl(taskId, fileId, requestOptions));
    }
    __getTaskOutputFilePresignedUrl(taskId, fileId, requestOptions) {
        return __awaiter$2(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, `files/tasks/${encodeURIComponent(taskId)}/output-files/${encodeURIComponent(fileId)}`),
                method: "GET",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 404:
                        throw new NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    case 500:
                        throw new InternalServerError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling GET /files/tasks/{task_id}/output-files/{file_id}.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    _getCustomAuthorizationHeaders() {
        return __awaiter$2(this, void 0, void 0, function* () {
            const apiKeyValue = yield Supplier.get(this._options.apiKey);
            return { "X-Browser-Use-API-Key": apiKeyValue };
        });
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
var __awaiter$1 = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
class Profiles {
    constructor(_options) {
        this._options = _options;
    }
    /**
     * Get paginated list of profiles.
     *
     * @param {BrowserUse.ListProfilesProfilesGetRequest} request
     * @param {Profiles.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.UnprocessableEntityError}
     *
     * @example
     *     await client.profiles.listProfiles()
     */
    listProfiles(request = {}, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__listProfiles(request, requestOptions));
    }
    __listProfiles() {
        return __awaiter$1(this, arguments, void 0, function* (request = {}, requestOptions) {
            var _a, _b, _c;
            const { pageSize, pageNumber } = request;
            const _queryParams = {};
            if (pageSize != null) {
                _queryParams["pageSize"] = pageSize.toString();
            }
            if (pageNumber != null) {
                _queryParams["pageNumber"] = pageNumber.toString();
            }
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, "profiles"),
                method: "GET",
                headers: _headers,
                queryParameters: Object.assign(Object.assign({}, _queryParams), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams),
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling GET /profiles.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Profiles allow you to preserve the state of the browser between tasks.
     *
     * They are most commonly used to allow users to preserve the log-in state in the agent between tasks.
     * You'd normally create one profile per user and then use it for all their tasks.
     *
     * You can create a new profile by calling this endpoint.
     *
     * @param {Profiles.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.PaymentRequiredError}
     * @throws {@link BrowserUse.UnprocessableEntityError}
     *
     * @example
     *     await client.profiles.createProfile()
     */
    createProfile(requestOptions) {
        return HttpResponsePromise.fromPromise(this.__createProfile(requestOptions));
    }
    __createProfile(requestOptions) {
        return __awaiter$1(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, "profiles"),
                method: "POST",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 402:
                        throw new PaymentRequiredError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling POST /profiles.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Get profile details.
     *
     * @param {string} profileId
     * @param {Profiles.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.NotFoundError}
     * @throws {@link BrowserUse.UnprocessableEntityError}
     *
     * @example
     *     await client.profiles.getProfile("profile_id")
     */
    getProfile(profileId, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__getProfile(profileId, requestOptions));
    }
    __getProfile(profileId, requestOptions) {
        return __awaiter$1(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, `profiles/${encodeURIComponent(profileId)}`),
                method: "GET",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: _response.body, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 404:
                        throw new NotFoundError(_response.error.body, _response.rawResponse);
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling GET /profiles/{profile_id}.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    /**
     * Permanently delete a browser profile and its configuration.
     *
     * @param {string} profileId
     * @param {Profiles.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link BrowserUse.UnprocessableEntityError}
     *
     * @example
     *     await client.profiles.deleteBrowserProfile("profile_id")
     */
    deleteBrowserProfile(profileId, requestOptions) {
        return HttpResponsePromise.fromPromise(this.__deleteBrowserProfile(profileId, requestOptions));
    }
    __deleteBrowserProfile(profileId, requestOptions) {
        return __awaiter$1(this, void 0, void 0, function* () {
            var _a, _b, _c;
            let _headers = mergeHeaders((_a = this._options) === null || _a === void 0 ? void 0 : _a.headers, mergeOnlyDefinedHeaders(Object.assign({}, (yield this._getCustomAuthorizationHeaders()))), requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.headers);
            const _response = yield fetcher({
                url: join((_c = (_b = (yield Supplier.get(this._options.baseUrl))) !== null && _b !== void 0 ? _b : (yield Supplier.get(this._options.environment))) !== null && _c !== void 0 ? _c : BrowserUseEnvironment.Production, `profiles/${encodeURIComponent(profileId)}`),
                method: "DELETE",
                headers: _headers,
                queryParameters: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.queryParams,
                timeoutMs: (requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.timeoutInSeconds) != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
                maxRetries: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.maxRetries,
                abortSignal: requestOptions === null || requestOptions === void 0 ? void 0 : requestOptions.abortSignal,
            });
            if (_response.ok) {
                return { data: undefined, rawResponse: _response.rawResponse };
            }
            if (_response.error.reason === "status-code") {
                switch (_response.error.statusCode) {
                    case 422:
                        throw new UnprocessableEntityError(_response.error.body, _response.rawResponse);
                    default:
                        throw new BrowserUseError({
                            statusCode: _response.error.statusCode,
                            body: _response.error.body,
                            rawResponse: _response.rawResponse,
                        });
                }
            }
            switch (_response.error.reason) {
                case "non-json":
                    throw new BrowserUseError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.rawBody,
                        rawResponse: _response.rawResponse,
                    });
                case "timeout":
                    throw new BrowserUseTimeoutError("Timeout exceeded when calling DELETE /profiles/{profile_id}.");
                case "unknown":
                    throw new BrowserUseError({
                        message: _response.error.errorMessage,
                        rawResponse: _response.rawResponse,
                    });
            }
        });
    }
    _getCustomAuthorizationHeaders() {
        return __awaiter$1(this, void 0, void 0, function* () {
            const apiKeyValue = yield Supplier.get(this._options.apiKey);
            return { "X-Browser-Use-API-Key": apiKeyValue };
        });
    }
}

/**
 * This file was auto-generated by Fern from our API Definition.
 */
let BrowserUseClient$1 = class BrowserUseClient {
    constructor(_options) {
        this._options = Object.assign(Object.assign({}, _options), { headers: mergeHeaders({
                "X-Fern-Language": "JavaScript",
                "X-Fern-SDK-Name": "browser-use-sdk",
                "X-Fern-SDK-Version": "2.0.4",
                "User-Agent": "browser-use-sdk/2.0.4",
                "X-Fern-Runtime": RUNTIME.type,
                "X-Fern-Runtime-Version": RUNTIME.version,
            }, _options === null || _options === void 0 ? void 0 : _options.headers) });
    }
    get accounts() {
        var _a;
        return ((_a = this._accounts) !== null && _a !== void 0 ? _a : (this._accounts = new Accounts(this._options)));
    }
    get tasks() {
        var _a;
        return ((_a = this._tasks) !== null && _a !== void 0 ? _a : (this._tasks = new Tasks(this._options)));
    }
    get sessions() {
        var _a;
        return ((_a = this._sessions) !== null && _a !== void 0 ? _a : (this._sessions = new Sessions(this._options)));
    }
    get files() {
        var _a;
        return ((_a = this._files) !== null && _a !== void 0 ? _a : (this._files = new Files(this._options)));
    }
    get profiles() {
        var _a;
        return ((_a = this._profiles) !== null && _a !== void 0 ? _a : (this._profiles = new Profiles(this._options)));
    }
};

var fastJsonStableStringify = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for (i = 0; i < node.length; i++) {
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    })(data);
};

var stringify = /*@__PURE__*/getDefaultExportFromCjs(fastJsonStableStringify);

/**
 * Makes a type check that is only valid when all cases of a switch
 * statement have been convered.
 */
class ExhaustiveSwitchCheck extends Error {
    constructor(val) {
        super(`Unreachable case: ${JSON.stringify(val)}`);
    }
}

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __await = (undefined && undefined.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); };
var __asyncGenerator = (undefined && undefined.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;
    function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }
    function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
var __asyncValues = (undefined && undefined.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
function stringifyStructuredOutput(schema) {
    return JSON.stringify(z.toJSONSchema(schema));
}
function parseStructuredTaskOutput(res, schema) {
    if (res.output == null) {
        return Object.assign(Object.assign({}, res), { parsed: null });
    }
    try {
        const parsed = JSON.parse(res.output);
        const response = schema.safeParse(parsed);
        if (!response.success) {
            throw new Error(`Invalid structured output: ${response.error.message}`);
        }
        return Object.assign(Object.assign({}, res), { parsed: response.data });
    }
    catch (e) {
        if (e instanceof SyntaxError) {
            return Object.assign(Object.assign({}, res), { parsed: null });
        }
        throw e;
    }
}
/**
 * Hashes the task view to detect changes.
 * Uses fast-json-stable-stringify for deterministic JSON, then SHA-256.
 */
function getTaskViewHash(view) {
    const dump = stringify(view);
    const hash = createHash("sha256").update(dump).digest("hex");
    return hash;
}
function wrapCreateTaskResponse(client, response, schema) {
    // NOTE: We create utility functions for streaming and watching internally in the function
    //       to expose them as utility methods to the base object.
    function _watch(taskId, config, options) {
        return __asyncGenerator(this, arguments, function* _watch_1() {
            var _a, _b;
            const intervalMs = (_a = config === null || config === void 0 ? void 0 : config.interval) !== null && _a !== void 0 ? _a : 2000;
            const hash = { current: null };
            poll: do {
                if ((_b = options === null || options === void 0 ? void 0 : options.signal) === null || _b === void 0 ? void 0 : _b.aborted) {
                    break poll;
                }
                const res = yield __await(client.getTask(taskId));
                const resHash = getTaskViewHash(res);
                if (hash.current == null || resHash !== hash.current) {
                    hash.current = resHash;
                    yield yield __await({ event: "status", data: res });
                }
                switch (res.status) {
                    case "finished":
                    case "stopped":
                    case "paused":
                        break poll;
                    case "started":
                        yield __await(new Promise((resolve) => setTimeout(resolve, intervalMs)));
                        break;
                    default:
                        throw new ExhaustiveSwitchCheck(res.status);
                }
            } while (true);
        });
    }
    /**
     * Streams the steps of the task and closes when the task is finished.
     *
     * @description Logs each step of the task exactly once. If you start the stream again, it will log the steps again.
     */
    function stream(config, options) {
        return __asyncGenerator(this, arguments, function* stream_1() {
            var _a, e_1, _b, _c;
            const steps = { total: 0 };
            try {
                for (var _d = true, _e = __asyncValues(_watch(response.id, config, options)), _f; _f = yield __await(_e.next()), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const msg = _c;
                    for (let i = steps.total; i < msg.data.steps.length; i++) {
                        steps.total = i + 1;
                        yield yield __await(msg.data.steps[i]);
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield __await(_b.call(_e));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    function watch(schema, config, options) {
        return __asyncGenerator(this, arguments, function* watch_1() {
            var _a, e_2, _b, _c;
            var _d;
            try {
                for (var _e = true, _f = __asyncValues(_watch(response.id, config, options)), _g; _g = yield __await(_f.next()), _a = _g.done, !_a; _e = true) {
                    _c = _g.value;
                    _e = false;
                    const msg = _c;
                    if ((_d = options === null || options === void 0 ? void 0 : options.signal) === null || _d === void 0 ? void 0 : _d.aborted) {
                        break;
                    }
                    if (schema != null) {
                        const parsed = parseStructuredTaskOutput(msg.data, schema);
                        yield yield __await({ event: "status", data: parsed });
                    }
                    else {
                        yield yield __await({ event: "status", data: msg.data });
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (!_e && !_a && (_b = _f.return)) yield __await(_b.call(_f));
                }
                finally { if (e_2) throw e_2.error; }
            }
        });
    }
    function complete(schema, config, options) {
        return __awaiter(this, void 0, void 0, function* () {
            var _a, e_3, _b, _c;
            try {
                for (var _d = true, _e = __asyncValues(_watch(response.id, config, options)), _f; _f = yield _e.next(), _a = _f.done, !_a; _d = true) {
                    _c = _f.value;
                    _d = false;
                    const msg = _c;
                    switch (msg.data.status) {
                        case "finished":
                        case "stopped":
                        case "paused": {
                            if (schema != null) {
                                const parsed = parseStructuredTaskOutput(msg.data, schema);
                                return parsed;
                            }
                            else {
                                const result = msg.data;
                                return result;
                            }
                        }
                        case "started":
                            break;
                        default:
                            throw new ExhaustiveSwitchCheck(msg.data.status);
                    }
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (!_d && !_a && (_b = _e.return)) yield _b.call(_e);
                }
                finally { if (e_3) throw e_3.error; }
            }
            throw new Error("Stream ended before the task finished!");
        });
    }
    // NOTE: Finally, we return the wrapped task response.
    if (schema == null) {
        const wrapped = Object.assign(Object.assign({}, response), { stream: (config, options) => stream(config, options), watch: (config, options) => watch(null, config, options), complete: (config, options) => complete(null, config, options) });
        return wrapped;
    }
    else {
        const wrapped = Object.assign(Object.assign({}, response), { stream: (config, options) => stream(config, options), watch: (config, options) => watch(schema, config, options), complete: (config, options) => complete(schema, config, options) });
        return wrapped;
    }
}

class BrowserUseTasks extends Tasks {
    constructor(options) {
        super(options);
    }
    createTask(request, requestOptions) {
        if ("schema" in request) {
            const req = Object.assign(Object.assign({}, request), { structuredOutput: stringifyStructuredOutput(request.schema) });
            const promise = super
                .createTask(req, requestOptions)
                .withRawResponse()
                .then((res) => {
                const wrapped = wrapCreateTaskResponse(this, res.data, request.schema);
                return {
                    data: wrapped,
                    rawResponse: res.rawResponse,
                };
            });
            return HttpResponsePromise.fromPromise(promise);
        }
        const promise = super
            .createTask(request, requestOptions)
            .withRawResponse()
            .then((res) => {
            const wrapped = wrapCreateTaskResponse(this, res.data, null);
            return {
                data: wrapped,
                rawResponse: res.rawResponse,
            };
        });
        return HttpResponsePromise.fromPromise(promise);
    }
    getTask(request, requestOptions) {
        if (typeof request === "string") {
            return super.getTask(request, requestOptions);
        }
        const { taskId, schema } = request;
        const promise = super
            .getTask(taskId, requestOptions)
            .withRawResponse()
            .then((res) => {
            const parsed = parseStructuredTaskOutput(res.data, schema);
            return {
                data: parsed,
                rawResponse: res.rawResponse,
            };
        });
        return HttpResponsePromise.fromPromise(promise);
    }
}

class BrowserUseClient extends BrowserUseClient$1 {
    get tasks() {
        var _a;
        return ((_a = this._tasks) !== null && _a !== void 0 ? _a : (this._tasks = new BrowserUseTasks(this._options)));
    }
}

export { BrowserUseClient };
